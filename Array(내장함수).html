<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Array(내장함수)</title>
</head>
<body>
	<div id="div1"></div>

	<script>
		// toString() : 문자열로 변환
		var fruits1 = ["Banana", "Orange", "Apple"];
		console.log(fruits1);
		console.log(fruits1.toString());

		// join() : 특정 문자를 구분자로 해서 문자열로 변환
		console.log(fruits1.join()); // 기본 값 "." = toString과 같음
		console.log(fruits1.join(" | "));

		var str1 = fruits1.join(" | ");
		console.log(str1);

		var arr = str1.split(" | ");
		console.log(arr);

		// 일일이 추가 => 비효율적
		var txt1 = "Banana<br>";
		txt1 += "Orange<br>";
		txt1 += "Apple<br>";

		console.log(txt1);
		document.getElementById("div1").innerHTML = txt1;

		var arr1 = [];
		arr1.push("Banana");
		arr1.push("Orange");
		arr1.push("Apple");
		console.log(arr1);

		document.getElementById("div1").innerHTML = arr1.join("<br>");

		// pop() : 배열의 가장 마지막 항목을 제거하여 리턴
		var fruits2 = ["Banana", "Orange", "Apple"];
		var str = fruits2.pop();
		console.log(str);
		console.log(fruits2);

		// push() : 배열의 가장 마지막에 항목을 추가
		fruits2.push("Kiwi");
		console.log(fruits2);

		// shift() : 배열의 가장 첫 번째 항목을 제거하여 리턴함
		var fruits3 = ["Banana", "Orange", "Apple"];
		var str = fruits3.shift();
		console.log(str);
		console.log(fruits3);

		// unshift() : 배열의 가장 첫 번째에 새로운 항목을 추가
		var fruits4 = ["Banana", "Orange", "Apple"];
		fruits4.unshift("Lemon");
		console.log(fruits4);

		// Stack 구현 => push(), pop()
		// Queue 구현 => push(), shift()
		// Deque 구현 => push(), pop(), shift(), unshift()

		// splice(a,b,c) (a = 시작 위치 / b = 삭제할 항목 수 / c = 추가할 항목)
		var fruits5 = ["Banana", "Orange", "Apple"];
		// fruits5.splice(1, 2); // 1번 인덱스 항목부터 2개 삭제
		// fruits5.splice(1, 0, "Lemon", "Kiwi");
		fruits5.splice(1, 1, "Lemon", "Kiwi");
		console.log(fruits5);

		// concat() : 두 개의 배열을 하나로 합쳐줌.
		var BTS1 = ["뷔"];
		var BTS2 = ["정국", "RM"];
		var BTS = BTS1.concat(BTS2);
		console.log(BTS);

		// slice(a, b) : a부터 b-1까지의 아이템을 가져옴
		var fruits6 = ["Banana", "Orange", "Apple"];
		var arr = fruits6.slice(1);
		var arr = fruits6.slice(1, 3);
		console.log(arr);

		// sort() : 정렬
		var fruits7 = ["Banana", "Orange", "Apple", "Lemon", "Peach"];
		console.log(fruits7.sort());

		var points = [40, 100, 70, 21, 99];
		console.log(points.sort()); // 출력 값 : 100, 21, 40, 70, 99 (숫자를 문자로 인식)
		
		// points.sort(function(a, b) { // 함수 재정의 (콜백함수)
		// 	// 오름차순 정렬
		// 	if(a > b)
		// 		return 1;
		// 	else if(a < b)
		// 		return -1;
		// 	else
		// 		return 0;
		// });

		points.sort(function(a, b) {
			return a - b; // 오름차순 정렬
			// return b - a; // 내림차순 정렬
		});
		console.log(points);
		console.log(points.reverse()); // 내림차순 정렬

		// object 정렬 (java는 call by value만 정렬 가능)
		var persons = [
			{name:"유재석", point:78},
			{name:"김종국", point:92},
			{name:"양세찬", point:76},
			{name:"하 하", point:81}
		];

		// persons.sort(function(a, b) {
		// 	if(a.point > b.point)
		// 		return 1;
		// 	else if(a.point < b.point)
		// 		return -1;
		// 	else
		// 		return 0;
		// });

		persons.sort(function(a, b) {
			return (a.point > b.point) ? 1 : (a.point < b.point) ? -1 : 0;
		})

		console.log(persons);

		// filter() : 조건에 맞는 배열만 리턴
		var persons = [
			{name:"유재석", point:78},
			{name:"김종국", point:92},
			{name:"양세찬", point:76},
			{name:"하 하", point:81}
		];

		var pass = persons.filter(function(per) {
			return per.point >= 80;
		});

		console.log(pass);

		var persons = [
			{name:"유재석", point:78, city:"서울"},
			{name:"김종국", point:92, city:"대구"},
			{name:"양세찬", point:76, city:"서울"},
			{name:"하 하", point:81, city:"제주"}
		];

		// filter() 없이 구현하기
		var jeju = [];
		persons.forEach((p) => {
			if(p.city === "제주")
				jeju.push(p);
		});
		console.log(jeju);

		var jeju = persons.filter(function(obj) {
			return obj.city === "제주";
		});
		console.log(jeju);

		// reduce(a, c)
		var arr3 = [1, 2, 3, 4];
		var sum = 0;
		for(var x of arr3){
			sum += x;
		}
		console.log(sum);

		var arr4 = [1, 2, 3, 4];
		var sum = arr4.reduce(function(a, c) {
			return a + c;
		});
		console.log(sum);

		// map() : filter와는 다른 형태로 새로운 배열을 생성
		var userList = [
			{firstName:"재석", lastName:"유", email:"yu@gmail.com"},
			{firstName:"종국", lastName:"김", email:"kim@gmail.com"},
			{firstName:"세찬", lastName:"양", email:"yang@gmail.com"},
			{firstName:"석진", lastName:"지", email:"ji@gmail.com"},
		];

		var userList2 = userList.map(function(user) {
			return {fullName:user.lastName + " " + user.firstName, sbs:"런닝맨"};
		});
		console.log(userList2);

	</script>
</body>
</html>